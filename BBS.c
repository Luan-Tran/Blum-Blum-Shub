/*
 * Author: Luan Tran
 * Date: 8/6/18
 * Description: This a implementation of the Blum Blum Shub algorithm that was
 * described in Bruce Schneier's book, Applied Cryptography. The algorithm
 * creates two large primes p and q, such that both are congruent to 3 modulo 4.
 * Let n = p*q, with the final random number being x. x_0 represents the lsb of
 * x, x_i represents the ith bit from the lsb. First x_0 is generated by the lsb
 * of y^2 mod n, where y is a random number such that the gcd(y,n) = 1.
 * Then x_1 is generated by the lsb of x_0^2 mod n. Thus the bits are
 * generated by x_i = x_{i-1}^2 mod n
 *
 * To generate the large primes, the OpenSSL libraries were used.
 */
#include <stdio.h>
#include "BBS.h"

BIGNUM * generateKey(char * randSeed,int length){
   
   //If length of key is not even, return nullptr
   if( (length % 2) != 0){
      return NULL;
   }
   
   //Define length of a key
   int LENGTH = length/2;

   //Generate two prime numbers
   BIGNUM *primeP = BN_new();
   BIGNUM *primeQ = BN_new();
   BN_CTX *ctx = BN_CTX_new();
   BN_ULONG four = 4;
   RAND_seed(randSeed, sizeof(randSeed));
   
   //Check primeP is congruent 3 mod 4
   BN_generate_prime_ex(primeP,LENGTH,0, NULL,NULL,NULL);
   while(  BN_mod_word(primeP,four) != 3){
      BN_generate_prime_ex(primeP,LENGTH,0, NULL,NULL,NULL);
   }

   //Check primeQ is congruent 3 mod 4 and not equal to PrimeP
   BN_generate_prime_ex(primeQ,LENGTH,0,NULL,NULL,NULL);
   while( BN_mod_word(primeQ,four) != 3 && BN_cmp(primeP,primeQ) != 0){
      BN_generate_prime_ex(primeQ,LENGTH,0,NULL,NULL,NULL);
   }

   //Create Blum integer
   BIGNUM * blumInt = BN_new();
   BN_mul(blumInt,primeP,primeQ,ctx);

   //Create x, where gcd(x,blumInt) == 1
   BIGNUM * seed = BN_new();
   BIGNUM * rem = BN_new();
   BN_generate_prime_ex(seed,length,0,NULL,NULL,NULL);
   BN_gcd(rem,seed,blumInt,ctx);
   while( BN_is_one(rem) != 1){
      BN_generate_prime_ex(seed,length,0,NULL,NULL,NULL);
      BN_gcd(rem,seed,blumInt,ctx);
   }

   //Compute bits
   BIGNUM * finalRandNum = BN_new();
   BN_generate_prime_ex(finalRandNum,length,0,NULL,NULL,NULL);

   //Use temp to keep track of x_i and prev for x_{i-1}
   BIGNUM * prev = BN_new();
   BIGNUM * temp = BN_new();
   BN_mod_mul(temp,seed,seed,blumInt,ctx);
   BN_mod_mul(prev,seed,seed,blumInt,ctx);  //x_0 = x^2
   
   //Go through each bit
   int bit = BN_is_bit_set(prev,0);
   int size = BN_num_bits(finalRandNum);
   for(int idx = 0; idx < size;idx++){
      
      if(bit == 1){
         BN_set_bit(finalRandNum,idx);
         BN_set_bit(temp,idx);
      }
      else{
         BN_clear_bit(finalRandNum,idx);
         BN_clear_bit(temp,idx);
      }

      BN_mod_mul(prev,temp,temp,blumInt,ctx); 
      bit = BN_is_bit_set(prev,0);
   }//End of for
   
   //Free memory
   BN_free(primeP);
   BN_free(primeQ);
   BN_free(blumInt);
   BN_free(seed);
   BN_free(rem);
   BN_free(prev);
   BN_free(temp);


   return finalRandNum;
}

int randNum(int end){
   
   //Construct random string based on time
   time_t currTime;
   struct tm * info;
   time( &currTime);
   info = localtime(&currTime);
   char * timeStr = asctime(info);
   
   //Get random number from BBS and mod with end
   BIGNUM * randBN = generateKey(timeStr,512);
   int randNum = BN_mod_word(randBN,end);
   BN_free(randBN);

   return randNum;

}

//Used for testing
void testPRNG(){
   
   int end = 1000;
   int numbers[100] = {0};

   for(long int i =0; i < end; i++){
      int rand = randNum(100);
      numbers[rand] = numbers[rand] + 1;
   }

   for(int j = 0; j < 100; j++){
      double percent = (double)numbers[j]/end;
      printf("%d: %f %d \n",j,percent, numbers[j]);
   }


}

//Used for testing
void printBN(BIGNUM * number){
   BIO * out = BIO_new_fp(stdout,BIO_NOCLOSE);
   BN_print(out,number);
   BIO_free(out);
}


